# On assertions

Answer the following questions:

1. The following assertion fails `assertTrue(3 * .4 == 1.2)`. Explain why and describe how this type of check should be done.

2. What is the difference between `assertEquals` and `assertSame`? Show scenarios where they produce the same result and scenarios where they do not produce the same result.

3. In classes we saw that `fail` is useful to mark code that should not be executed because an exception was expected before. Find other uses for `fail`. Explain the use case and add an example.

4. In JUnit 4, an exception was expected using the `@Test` annotation, while in JUnit 5 there is a special assertion method `assertThrows`. In your opinion, what are the advantages of this new way of checking expected exceptions?

## Answer

1. L'assertion assertTrue(3 * 0.4 == 1.2) peut échouer en raison des limitations de précision liées à l'arithmétique des nombres à virgule flottante dans de nombreux langages de programmation. En raison de la représentation finie des nombres décimaux en virgule flottante, il peut y avoir des erreurs d'arrondi. En programmation, il est souvent recommandé d'utiliser une marge d'erreur, ou "tolérance", lors de la comparaison de nombres à virgule flottante. Au lieu de vérifier une égalité exacte, on compare si la différence entre les valeurs attendues et réelles est inférieure à une certaine marge.

2. assertEquals et assertSame sont deux méthodes utilisées dans les frameworks de test, tels que JUnit, pour vérifier les résultats attendus, mais elles servent à des objectifs différents. assertEquals compare les valeurs ou le contenu de deux objets, généralement à l'aide de la méthode equals, tandis que assertSame compare les références de deux objets pour s'assurer qu'elles pointent vers la même instance en mémoire. Par exemple, avec des types primitifs comme les entiers, ces deux méthodes peuvent produire le même résultat, mais avec des objets, elles diffèrent, car assertEquals se concentre sur l'égalité du contenu, tandis que assertSame se concentre sur l'identité des références. Il peut y avoir des cas où ces méthodes produisent le même résultat, par exemple lorsqu'on travaille avec des valeurs primitives ou des références nulles, mais dans d'autres situations, telles que la comparaison d'instances d'objets, elles peuvent conduire à des résultats différents en raison de leur nature respective de comparaison.

3. La méthode fail dans les frameworks de test tels que JUnit est principalement utilisée pour indiquer qu'une condition spécifique n'a pas été satisfaite, marquant ainsi un échec du test. Cependant, elle peut également être employée dans d'autres contextes. Par exemple, elle peut être utilisée pour générer une défaillance basée sur une condition particulière, offrant ainsi un contrôle plus précis sur les conditions d'échec. De plus, la méthode fail peut servir à marquer délibérément des parties de tests comme incomplètes, signalant ainsi aux développeurs qu'elles nécessitent une révision ou à des fins de saut temporaire lors du développement, permettant d'éviter l'exécution de certaines parties du code sans pour autant marquer le test comme réussi. Un autre cas d'utilisation est de signaler un échec lorsqu'une fonctionnalité n'est pas supportée ou prête. Cela peut être utile pour indiquer que certaines conditions requises ne sont pas remplies ou qu'une fonctionnalité spécifique n'est pas encore implémentée, guidant ainsi les développeurs vers les zones de code nécessitant une attention particulière. En résumé, la méthode fail peut être utilisée de manière polyvalente pour communiquer des conditions spécifiques, indiquer des parties incomplètes du code, ou signaler des fonctionnalités non supportées, fournissant ainsi une flexibilité supplémentaire dans les tests et le développement logiciel.

4. La transition de l'attente d'exceptions dans JUnit 4, à l'utilisation de la méthode d'assertion spéciale assertThrows dans JUnit 5, présente plusieurs avantages significatifs. Tout d'abord, assertThrows offre une syntaxe plus explicite et déclarative pour vérifier les exceptions attendues dans les tests. Cela rend le code plus lisible et compréhensible, car il indique clairement l'intention du testeur. De plus, assertThrows fournit une manière plus précise de spécifier l'exception attendue, car elle prend en paramètre une classe d'exception. Cela permet de capturer des détails plus spécifiques sur l'exception attendue, ce qui est souvent nécessaire pour des tests plus précis. Dans JUnit 4, la déclaration d'exception attendue était annotée directement sur la méthode de test, mais elle ne permettait pas de spécifier le type exact d'exception, ce qui pouvait parfois conduire à des tests moins précis.
